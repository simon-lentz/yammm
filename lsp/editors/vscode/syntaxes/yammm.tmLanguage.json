{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "YAMMM",
  "scopeName": "source.yammm",
  "patterns": [
    { "include": "#comments" },
    { "include": "#schema" },
    { "include": "#import" },
    { "include": "#datatype" },
    { "include": "#type-declaration" },
    { "include": "#strings" }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.block.yammm",
          "begin": "/\\*",
          "end": "\\*/"
        },
        {
          "name": "comment.line.double-slash.yammm",
          "match": "//.*$"
        }
      ]
    },
    "schema": {
      "match": "^\\s*(schema)\\s+(\"[^\"]*\"|'[^']*')",
      "captures": {
        "1": { "name": "keyword.control.schema.yammm" },
        "2": { "name": "string.quoted.yammm" }
      }
    },
    "import": {
      "comment": "Import statement with optional 'as alias' clause (grammar makes alias optional)",
      "match": "^\\s*(import)\\s+(\"[^\"]*\"|'[^']*')(?:\\s+(as)\\s+([a-zA-Z_][a-zA-Z0-9_]*))?",
      "captures": {
        "1": { "name": "keyword.control.import.yammm" },
        "2": { "name": "string.quoted.yammm" },
        "3": { "name": "keyword.control.as.yammm" },
        "4": { "name": "entity.name.namespace.yammm" }
      }
    },
    "type-declaration": {
      "begin": "^\\s*(abstract\\s+)?(part\\s+)?(type)\\s+([A-Z][a-zA-Z0-9_]*)(?:\\s+(extends)\\s+)?",
      "beginCaptures": {
        "1": { "name": "storage.modifier.abstract.yammm" },
        "2": { "name": "storage.modifier.part.yammm" },
        "3": { "name": "keyword.declaration.type.yammm" },
        "4": { "name": "entity.name.type.yammm" },
        "5": { "name": "keyword.other.extends.yammm" }
      },
      "end": "\\}",
      "endCaptures": {
        "0": { "name": "punctuation.definition.block.end.yammm" }
      },
      "patterns": [
        { "include": "#comments" },
        { "include": "#type-reference" },
        { "include": "#type-body" }
      ]
    },
    "type-reference": {
      "match": "([a-zA-Z_][a-zA-Z0-9_]*)(\\.)([A-Z][a-zA-Z0-9_]*)|([A-Z][a-zA-Z0-9_]*)",
      "captures": {
        "1": { "name": "entity.name.namespace.yammm" },
        "2": { "name": "punctuation.accessor.yammm" },
        "3": { "name": "entity.name.type.yammm" },
        "4": { "name": "entity.name.type.yammm" }
      }
    },
    "type-body": {
      "begin": "\\{",
      "beginCaptures": {
        "0": { "name": "punctuation.definition.block.begin.yammm" }
      },
      "end": "(?=\\})",
      "patterns": [
        { "include": "#comments" },
        { "include": "#invariant" },
        { "include": "#association" },
        { "include": "#composition" },
        { "include": "#rel-properties" },
        { "include": "#property" }
      ]
    },
    "rel-properties": {
      "comment": "Edge property block for associations: --> REL (mult) Target { prop Type }. Must be scoped here so its closing } is not mistaken for the type body's closing }.",
      "begin": "\\{",
      "beginCaptures": {
        "0": { "name": "punctuation.definition.block.begin.yammm" }
      },
      "end": "\\}",
      "endCaptures": {
        "0": { "name": "punctuation.definition.block.end.yammm" }
      },
      "patterns": [
        { "include": "#comments" },
        { "include": "#property" }
      ]
    },
    "property": {
      "comment": "Property declaration with name, type, optional constraint, and modifiers. Uses begin/end to allow each modifier to be captured independently.",
      "begin": "^\\s*([a-z_][a-zA-Z0-9_]*)\\s+",
      "beginCaptures": {
        "1": { "name": "variable.other.property.yammm" }
      },
      "end": "$",
      "patterns": [
        { "include": "#comments" },
        { "include": "#property-type" },
        { "include": "#property-constraint" },
        { "include": "#property-modifier" }
      ]
    },
    "property-type": {
      "comment": "Property type: built-in types or user types (qualified with lowercase alias allowed, e.g., parts.Wheel).",
      "match": "\\b(String|Integer|Float|Boolean|UUID|Date|Timestamp|Vector|Enum|Pattern|(?:[a-zA-Z_][a-zA-Z0-9_]*\\.)?[A-Z][a-zA-Z0-9_]*)\\b",
      "name": "support.type.yammm"
    },
    "property-constraint": {
      "begin": "\\[",
      "end": "\\]",
      "beginCaptures": {
        "0": { "name": "punctuation.definition.bracket.begin.yammm" }
      },
      "endCaptures": {
        "0": { "name": "punctuation.definition.bracket.end.yammm" }
      },
      "name": "meta.constraint.yammm",
      "patterns": [
        { "include": "#strings" },
        { "include": "#numbers" },
        { "include": "#expression-keywords" },
        { "include": "#comments" }
      ]
    },
    "property-modifier": {
      "comment": "Property modifiers per grammar: only 'required' or 'primary' (not 'optional')",
      "match": "\\b(required|primary)\\b",
      "name": "storage.modifier.yammm"
    },
    "association": {
      "comment": "Association declaration with optional multiplicity. Type reference allows lowercase qualifier for imports (e.g., parts.Wheel).",
      "match": "^\\s*(-->)\\s+([A-Za-z_][A-Za-z0-9_]*)(?:\\s+(\\()\\s*(_(?::(?:one|many))?|one(?::(?:one|many))?|many)\\s*(\\)))?\\s+((?:[a-zA-Z_][a-zA-Z0-9_]*\\.)?[A-Z][a-zA-Z0-9_]*)",
      "captures": {
        "1": { "name": "entity.name.function.relation.yammm" },
        "2": { "name": "entity.name.function.relation.yammm" },
        "3": { "name": "punctuation.definition.parameters.begin.yammm" },
        "4": { "name": "constant.language.multiplicity.yammm" },
        "5": { "name": "punctuation.definition.parameters.end.yammm" },
        "6": { "name": "entity.name.type.yammm" }
      }
    },
    "composition": {
      "comment": "Composition declaration with optional multiplicity. Type reference allows lowercase qualifier for imports (e.g., parts.Wheel).",
      "match": "^\\s*(\\*->)\\s+([A-Za-z_][A-Za-z0-9_]*)(?:\\s+(\\()\\s*(_(?::(?:one|many))?|one(?::(?:one|many))?|many)\\s*(\\)))?\\s+((?:[a-zA-Z_][a-zA-Z0-9_]*\\.)?[A-Z][a-zA-Z0-9_]*)",
      "captures": {
        "1": { "name": "entity.name.function.relation.yammm" },
        "2": { "name": "entity.name.function.relation.yammm" },
        "3": { "name": "punctuation.definition.parameters.begin.yammm" },
        "4": { "name": "constant.language.multiplicity.yammm" },
        "5": { "name": "punctuation.definition.parameters.end.yammm" },
        "6": { "name": "entity.name.type.yammm" }
      }
    },
    "invariant": {
      "comment": "Invariant declaration. begin matches ! and message string. end lookahead terminates when next declaration starts (property, invariant, relationship, or closing brace).",
      "begin": "^\\s*(!)\\s+(\"[^\"]*\"|'[^']*')",
      "beginCaptures": {
        "1": { "name": "keyword.declaration.invariant.yammm" },
        "2": { "name": "string.quoted.invariant-message.yammm" }
      },
      "end": "(?=^\\s*(?:!\\s+\"|[a-z_]\\w*\\s+[A-Z]|-->|\\*->|\\}))",
      "name": "meta.invariant-expression.yammm",
      "patterns": [
        { "include": "#comments" },
        { "include": "#strings" },
        { "include": "#regex-literal" },
        { "include": "#numbers" },
        { "include": "#expression-operators" },
        { "include": "#expression-keywords" },
        { "include": "#expression-identifiers" }
      ]
    },
    "datatype": {
      "comment": "Datatype alias: type Name = BaseType[constraint]. Uses begin/end so constraint delegates to #property-constraint for nested highlighting.",
      "begin": "^\\s*(type)\\s+([A-Z][a-zA-Z0-9_]*)\\s*(=)\\s*(String|Integer|Float|Boolean|UUID|Date|Timestamp|Vector|Enum|Pattern)",
      "beginCaptures": {
        "1": { "name": "keyword.declaration.type.yammm" },
        "2": { "name": "entity.name.type.yammm" },
        "3": { "name": "keyword.operator.assignment.yammm" },
        "4": { "name": "support.type.yammm" }
      },
      "end": "(?<=\\])|$",
      "patterns": [
        { "include": "#property-constraint" },
        { "include": "#comments" }
      ]
    },
    "expression-operators": {
      "comment": "Expression operators. Multi-char operators listed before single-char to avoid partial matches. \\|\\| matches literal ||.",
      "match": "==|!=|>=|<=|=~|!~|\\|\\||&&|->|[><+\\-*/%!^]|\\bin\\b",
      "name": "keyword.operator.yammm"
    },
    "expression-keywords": {
      "comment": "Expression keyword literals. \\b_\\b matches standalone _ (nil) but not _ inside identifiers like is_active.",
      "match": "\\b(true|false|nil|_)\\b",
      "name": "constant.language.yammm"
    },
    "expression-identifiers": {
      "patterns": [
        {
          "comment": "Lambda parameter variable ($name)",
          "match": "\\$[a-zA-Z_][a-zA-Z0-9_]*",
          "name": "variable.parameter.lambda.yammm"
        },
        {
          "comment": "Function name (uppercase-initial, e.g., Len, IsNil, Contains)",
          "match": "\\b[A-Z][a-zA-Z0-9_]*\\b",
          "name": "entity.name.function.yammm"
        },
        {
          "comment": "Property name or identifier (lowercase-initial)",
          "match": "\\b[a-z_][a-zA-Z0-9_]*\\b",
          "name": "variable.other.expression.yammm"
        }
      ]
    },
    "numbers": {
      "match": "\\b\\d+(\\.\\d+)?\\b",
      "name": "constant.numeric.yammm"
    },
    "regex-literal": {
      "comment": "Regex literal delimited by forward slashes (used with =~ and !~ operators). Takes priority over expression-operators to prevent regex content being tokenized as individual operators/identifiers.",
      "begin": "/",
      "end": "/",
      "beginCaptures": {
        "0": { "name": "punctuation.definition.string.begin.yammm" }
      },
      "endCaptures": {
        "0": { "name": "punctuation.definition.string.end.yammm" }
      },
      "name": "string.regexp.yammm",
      "patterns": [
        {
          "name": "constant.character.escape.yammm",
          "match": "\\\\."
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.yammm",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.yammm",
              "match": "\\\\."
            }
          ]
        },
        {
          "name": "string.quoted.single.yammm",
          "begin": "'",
          "end": "'",
          "patterns": [
            {
              "name": "constant.character.escape.yammm",
              "match": "\\\\."
            }
          ]
        }
      ]
    }
  }
}
