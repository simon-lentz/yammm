schema "collection_builtins"

// Tests collection builtins (non-lambda): Sum, First, Last, Sort, Reverse,
// Flatten, Compact, Unique, Contains.
// Literal-based invariants verify exact transformation outputs.
// Property-based invariants prove algebraic correctness (idempotence, involution).
type CollectionRecord {
	id  String primary
	csv String required

	// --- Sum: adds numeric elements ---
	! "sum" [1, 2, 3] -> Sum == 6

	// --- First / Last: element access ---
	! "first" [10, 20, 30] -> First == 10
	! "last" [10, 20, 30] -> Last == 30

	// --- Sort: ascending order via value.ValueOrder ---

	// Exact output for known input
	! "sort_exact" [3, 1, 2] -> Sort == [1, 2, 3]
	// Last element is max
	! "sort_last" [3, 1, 2] -> Sort -> Last == 3
	// Idempotence: sorting an already-sorted list is a no-op
	! "sort_idempotent" [3, 1, 2] -> Sort -> Sort == [3, 1, 2] -> Sort
	// Length preservation
	! "sort_len" [3, 1, 2] -> Sort -> Len == 3

	// --- Reverse: reverses element order ---

	// Exact output for known input
	! "reverse_exact" [1, 2, 3] -> Reverse == [3, 2, 1]
	// Involution: double reverse is identity
	! "reverse_involution" [1, 2, 3] -> Reverse -> Reverse == [1, 2, 3]
	// Last element of reversed list is first of original
	! "reverse_last" [1, 2, 3] -> Reverse -> Last == 1
	// Length preservation
	! "reverse_len" [1, 2, 3] -> Reverse -> Len == 3

	// --- Flatten: unpacks one level of nesting ---

	// Exact output for known input
	! "flatten_exact" [[1, 2], [3]] -> Flatten == [1, 2, 3]
	// Multiple sub-lists
	! "flatten_multi" [[1], [2], [3]] -> Flatten == [1, 2, 3]
	// Non-nested input is passthrough
	! "flatten_passthrough" [1, 2, 3] -> Flatten == [1, 2, 3]

	// --- Compact: removes nil entries ---

	// Exact output for known input
	! "compact_exact" [1, _, 3] -> Compact == [1, 3]
	// All-nil produces empty list
	! "compact_all_nil" [_, _, _] -> Compact -> Len == 0
	// No-nil input is passthrough
	! "compact_passthrough" [1, 2, 3] -> Compact == [1, 2, 3]

	// --- Unique: removes duplicates (preserves first occurrence order) ---

	// Exact output for known input
	! "unique_exact" [1, 2, 2, 3, 3] -> Unique == [1, 2, 3]
	// All-same reduces to single element
	! "unique_all_same" [1, 1, 1] -> Unique == [1]
	// Already-unique input is passthrough
	! "unique_passthrough" [1, 2, 3] -> Unique == [1, 2, 3]
	// Idempotence: Unique(Unique(x)) == Unique(x)
	! "unique_idempotent" [1, 2, 2, 3, 3] -> Unique -> Unique == [1, 2, 2, 3, 3] -> Unique

	// --- Contains: checks element membership ---
	! "contains_list" [1, 2, 3] -> Contains(2)
	! "contains_missing" [1, 2, 3] -> Contains(99) == false
	! "contains_csv" csv -> Split(",") -> Contains("a")
}
